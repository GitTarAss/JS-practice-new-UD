'use strict';
// https://repl.it/@MaximUsa/Simvoly-Symbols
let name = Symbol('Иван');
console.log(name); //Символу можно задать метку, передав её в функцию Symbol. Метка доступна только при вызове метода toString и при выводе в консоль
console.log(name.toString() === 'Symbol(Иван)');
/*
Метку можно использовать только для отладочных целей. Потому что о символе без метки мы не знаем вообще ничего
*/
/*
Ключевая особенность символов — их уникальность. Вы не сможете
создать два одинаковых символа. Даже если метки одинаковые, символы будут разные
*/
let name1 = Symbol('Иван');
let name2 = Symbol('Иван');
console.log(name1 === name2); // false
/*
попробуйте создавать символы в глобальном реестре с помощью функции Symbol.for
«глобальный реестр» позволяет иметь общие «глобальные» символы, которые можно получить из реестра по имени
Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя)
 Функция принимает строку ключ в качестве аргумента
*/
// создание символа в реестре
let name4 = Symbol.for("name3");
console.log (Symbol.keyFor(name4));//по глобальному символу (по переменной name3, в которой сохранен символ) получили имя

// символ уже есть, чтение из реестра
console.log( Symbol.for("name3") == name4 ); // true
/*
У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym). Он позволяет получить по глобальному символу его имя:
*/
// создание символа в реестре
let test = Symbol.for("name");

// получение имени символа
console.log ( Symbol.keyFor(test) ); // name
//Заметим, что Symbol.keyFor работает только для глобальных символов, для остальных будет возвращено undefined:
console.log ( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный
console.log ( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ

//Символы можно использовать в качестве имён для свойств объекта следующим образом
let isAdmin = Symbol("isAdmin");// в переменной сохранили символ, переменная и есть теперь символ, используем переменную в качестве уникального имени, isAdmin зарезервировано как символ

let user = {
  name: "Вася",
  [isAdmin]: true
};

console.log (user[isAdmin]); // true

// Особенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации
let user1 = {
  name: "Вася",
  age: 30,
  [Symbol.for("isAdmin")]: true
};

// в цикле for..in также не будет символа
console.log ( Object.keys(user1) ); // name, age

// доступ к свойству через глобальный символ — работает
console.log ( user1[Symbol.for("isAdmin")] );
//свойство-символ недоступно, если обратиться к его названию: user.isAdmin не существует.
/*
Допустим, в новом стандарте нам надо добавить к объекту «особый» функционал, например, функцию, которая задаёт преобразование объекта к примитиву. Как obj.toString, но для преобразования в примитивы.

Мы ведь не можем просто сказать, что «свойство obj.toPrimitive теперь будет задавать преобразование к примитиву и автоматически вызываться в таких-то ситуациях». Это опасно. Мы не можем так просто взять и придать особый смысл свойству. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде, и если сделать его особым, то он сломается.
Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.
Поэтому ввели целый тип «символы». Их можно использовать для задания таких свойств, так как они:

а) уникальны,
б) не участвуют в циклах,
в) заведомо не сломают старый код, который о них слыхом не слыхивал.
*/
//Продемонстрируем отсутствие конфликта для нового системного свойства Symbol.iterator:
let obj = {
  iterator: 1,
  [Symbol.iterator]() {}
};

console.log (obj.iterator); // 1
console.log (obj[Symbol.iterator]); // function, символ не конфликтует

//Выше мы использовали системный символ Symbol.iterator, поскольку он один из самых широко используемых. Мы подробно разберём его смысл в главе про итераторы, пока же – это просто пример символа.

/*
Чтобы получить все символы объекта, есть особый вызов Object.getOwnPropertySymbols.

Эта функция возвращает все символы в объекте (и только их). Заметим, что старая функция getOwnPropertyNames символы не возвращает, что опять же гарантирует отсутствие конфликтов со старым кодом.
*/
let obj1 = {
  iterator: 1,
  [Symbol.iterator]: function() {}
}

// один символ в объекте
console.log ( Object.getOwnPropertySymbols(obj1)[0].toString() ); // Symbol(Symbol.iterator)

// и одно обычное свойство
console.log ( Object.getOwnPropertyNames(obj1) ); // iterator

/*
Итого

Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.
Все символы уникальны. Символы с одинаковым именем не равны друг другу.
Существует глобальный реестр символов, доступных через метод Symbol.for("name"). Для глобального символа можно получить имя вызовом Symbol.keyFor(sym).
Основная область использования символов – это системные свойства объектов, которые задают разные аспекты их поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.

///////////////////
Системные символы доступны как свойства функции Symbol, например Symbol.iterator.
//////////////////

Мы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства Symbol, разумеется, нельзя. Если нужен глобально доступный символ, то используется Symbol.for(имя).
*/
const names = Object.create(null);
names.add = function (item) {
  this[Symbol()] = item;
};
names.add('Иван');
names.add('Олег');
for (let key of Object.getOwnPropertySymbols(names)) {
  console.log(names[key]);
}
/*
Мы можем смело добавлять сколько угодно свойств объекту, ключом
которых будет только что созданный символ. Все они добавятся и ничего не затрется. Вот только единственный способ до них добраться: получить все такие ключи через Object.getOwnPropertySymbols
*/